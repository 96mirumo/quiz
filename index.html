<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Daily Study Log</title>
    <style>
        :root { --bg: #ffffff; --text: #333; --border: #eee; --accent: #444; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; line-height: 1.6; }
        .container { max-width: 500px; margin: 0 auto; display: flex; flex-direction: column; min-height: 90vh; }
        .hidden { display: none !important; }
        
        .menu-card { background: #fff; border: 1px solid var(--border); border-radius: 8px; padding: 15px; margin-bottom: 10px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .score-badge { font-size: 0.75rem; color: #888; background: #f9f9f9; padding: 2px 8px; border-radius: 10px; }
        .unit-group { margin-bottom: 25px; }
        .group-label { font-size: 0.8rem; color: #999; margin: 0 0 8px 5px; font-weight: bold; }

        .q-card { border: 1px solid var(--border); padding: 20px; border-radius: 8px; text-align: center; margin-top: 10px; }
        .q-text { font-size: 1.05rem; font-weight: 600; margin-bottom: 25px; word-break: keep-all; }
        
        input[type="text"] { width: 90%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; margin-bottom: 15px; text-align: center; outline: none; }
        .option-btn { display: block; width: 100%; padding: 12px; margin-bottom: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; text-align: left; }
        
        .btn-row { display: flex; gap: 8px; margin-top: 15px; }
        .btn { flex: 1; padding: 14px; border-radius: 4px; border: 1px solid #ddd; background: #f5f5f5; cursor: pointer; font-size: 0.9rem; }
        .btn-next { background: var(--accent); color: #fff; border: none; }
        
        .status-msg { height: 20px; font-size: 0.85rem; margin-bottom: 10px; font-weight: bold; }
        .nav-link { display: block; text-align: center; margin-top: 30px; color: #aaa; font-size: 0.8rem; cursor: pointer; text-decoration: underline; }
        kbd { background: #eee; border-radius: 3px; padding: 1px 4px; font-size: 0.7rem; border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <div id="view-menu">
            <div style="height: 20px;"></div>
            <div class="unit-group">
                <div class="menu-card" onclick="resumeLast()" style="background:#444; color:#fff; border:none;">
                    <div>이전 문제 이어서 풀기</div>
                    <small id="resume-info" style="opacity:0.7;">기록 없음</small>
                </div>
                <div class="menu-card" onclick="startWrongAnswers()">
                    <div style="color:#666;">오답 노트 확인</div>
                    <small id="wrong-count" style="color:#999;">0개</small>
                </div>
            </div>
            <div class="unit-group">
                <div class="group-label">SECTION 01. 소프트웨어 구축 (중복없음)</div>
                <div id="set-list-1"></div>
            </div>
            <div id="other-units"></div>
        </div>

        <div id="view-quiz" class="hidden">
            <div style="display:flex; justify-content:space-between; font-size:0.75rem; color:#aaa; margin-bottom:10px;">
                <span id="display-title"></span>
                <span id="display-progress"></span>
            </div>
            <div class="q-card">
                <div id="status-msg" class="status-msg"></div>
                <div id="q-text" class="q-text"></div>
                <div id="area-subjective"><input type="text" id="user-ans" placeholder="정답 입력" autocomplete="off"></div>
                <div id="area-objective" class="hidden"></div>
                <div id="hint-box" class="hidden" style="background:#f9f9f9; padding:10px; font-size:0.85rem; margin:10px 0; border:1px dashed #ddd; text-align: left;"></div>
                <div class="btn-row" id="row-check">
                    <button class="btn" onclick="toggleHint()">Info <kbd>Ctrl</kbd></button>
                    <button class="btn" onclick="checkAnswer()">Verify <kbd>Enter</kbd></button>
                </div>
                <div class="btn-row hidden" id="row-next">
                    <button class="btn" onclick="toggleHint()">Info <kbd>Ctrl</kbd></button>
                    <button class="btn btn-next" onclick="nextQuestion()">Next <kbd>Enter</kbd></button>
                </div>
            </div>
            <div class="nav-link" style="margin-top:20px; color:#666;" onclick="prevQuestion()">[ 이전 문제로 가기 ]</div>
            <div class="nav-link" onclick="goHome()">목록으로 돌아가기</div>
        </div>
    </div>

    <script>
        // PDF 특강 기반 총 30문제 (10개씩 3세트 분리)
        const allQuestions = [
            // 세트 1 (0~9)
            { q: "소프트웨어 공학의 3R 중 '분석 -> 재구성 -> 역공학 -> 이관'의 절차를 가지는 것은?", a: ["재공학"], h: "Re-Engineering", type: "S" },
            { q: "애자일 방법론 중 XP의 5가지 핵심 가치가 아닌 것은?", a: ["가시성"], opts: ["용기", "존중", "가시성", "피드백"], h: "용단커피존", type: "O" },
            { q: "Rayleigh-Norden 곡선을 기초로 하는 수학적 산정 모델은?", a: ["putnam", "푸트남"], h: "SLIM 도구", type: "S" },
            { q: "요구사항 개발 프로세스: 도출 -> ( ) -> 명세 -> 확인. 괄호는?", a: ["분석"], h: "도분명확", type: "S" },
            { q: "비동기식 메시지 전송 미들웨어는?", a: ["MOM"], h: "Message Oriented Middleware", type: "S" },
            { q: "UML 관계 중 전체 객체가 소멸하면 부분 객체도 소멸하는 강한 포함 관계는?", a: ["합성 관계", "합성"], h: "Composition", type: "S" },
            { q: "사용자 시점의 시스템 기능을 표현하는 UML 다이어그램은?", a: ["유스케이스"], h: "Actor와 System 상호작용", type: "S" },
            { q: "GoF 생성 패턴에 해당하는 것은?", a: ["Builder"], opts: ["Adapter", "Facade", "Builder", "Proxy"], h: "추빌팩프싱", type: "O" },
            { q: "자식 클래스가 부모 클래스를 대체할 수 있어야 한다는 원칙은?", a: ["LSP", "리스코프 치환 원칙"], h: "SOLID 중 L", type: "S" },
            { q: "누구나 쉽게 배우고 익힐 수 있어야 함을 의미하는 UI 원칙은?", a: ["학습성"], h: "Understandability", type: "S" },
            // 세트 2 (10~19)
            { q: "동일한 시간대에 실행되는 모듈 요소들의 응집도는?", a: ["시간적 응집도"], h: "Temporal Cohesion", type: "S" },
            { q: "동일한 자료 구조를 참조하는 모듈 간의 결합도는?", a: ["스탬프 결합도"], h: "Stamp Coupling", type: "S" },
            { q: "복잡한 서브시스템에 단순한 접점을 제공하는 디자인 패턴은?", a: ["파사드", "Facade"], h: "건물의 정면", type: "S" },
            { q: "하향식 통합 테스트에서 사용하는 가상 모듈은?", a: ["스텁", "Stub"], h: "하상스", type: "S" },
            { q: "개-논-물 단계 중 트랜잭션 모델링이 일어나는 단계는?", a: ["논리적 설계"], h: "Logical Design", type: "S" },
            { q: "IP 계층에서 트래픽을 암호화하여 보안을 강화하는 규격은?", a: ["IPSec"], h: "Network Layer Security", type: "S" },
            { q: "결합도가 가장 낮은(좋은) 단계는?", a: ["자료 결합도"], h: "Data Coupling", type: "S" },
            { q: "데이터 흐름도(DFD)의 구성 요소 중 처리를 나타내는 기호는?", a: ["프로세스", "원"], h: "Process", type: "S" },
            { q: "스크럼에서 매일 진행하는 짧은 회의는?", a: ["데일리 스크럼"], h: "Daily Scrum", type: "S" },
            { q: "UI 설계 원칙 중 목표 달성을 정확하게 하는 성질은?", a: ["유효성"], h: "Effectiveness", type: "S" },
            // 세트 3 (20~29)
            { q: "모듈 내 요소들이 순차적으로 출력을 입력으로 사용하는 응집도는?", a: ["순차적 응집도"], h: "Sequential Cohesion", type: "S" },
            { q: "두 모듈이 동일한 외부 환경을 참조하는 결합도는?", a: ["외부 결합도"], h: "External Coupling", type: "S" },
            { q: "정적인 구조를 표현하는 대표적인 UML 다이어그램은?", a: ["클래스 다이어그램"], h: "Class Diagram", type: "S" },
            { q: "요구사항 검토 방법 중 팀이 모여 소스를 훑어보는 기법은?", a: ["워크스루"], h: "Walkthrough", type: "S" },
            { q: "시스템 성능 향상을 위해 중복 데이터를 허용하는 기법은?", a: ["반정규화"], h: "Denormalization", type: "S" },
            { q: "객체의 상태 변화를 관찰하여 통지하는 패턴은?", a: ["옵저버"], h: "Observer", type: "S" },
            { q: "상향식 통합 테스트에서 사용하는 가상 모듈은?", a: ["드라이버", "Driver"], h: "하상스", type: "S" },
            { q: "시스템 아키텍처 중 계층 구조를 가지는 가장 일반적인 패턴은?", a: ["계층 패턴", "Layered Pattern"], h: "Layered", type: "S" },
            { q: "컴포넌트 설계 시 내부 요소들이 얼마나 밀접한지 나타내는 것은?", a: ["응집도"], h: "Cohesion", type: "S" },
            { q: "UI 설계 시 오류 발생을 최소화하는 원칙은?", a: ["직관성"], opts: ["유효성", "직관성", "학습성", "유연성"], h: "Intuitiveness", type: "O" }
        ];

        let currentSet = [];
        let curIdx = 0;
        let setNum = 0;
        let isWrongMode = false;
        let firstTryResults = {}; // 최초 응답 결과 저장

        function renderMenu() {
            const setList1 = document.getElementById('set-list-1');
            setList1.innerHTML = '';
            for(let i=1; i<=3; i++) {
                const s = localStorage.getItem(`score_1_${i}`) || "-";
                setList1.innerHTML += `<div class="menu-card" onclick="startSet(1, ${i})"><div class="unit-title">세트 0${i}</div><div class="score-badge">${s}점</div></div>`;
            }
            const lastU = localStorage.getItem('last_unit');
            const lastS = localStorage.getItem('last_set');
            const lastI = localStorage.getItem('last_idx');
            document.getElementById('resume-info').innerText = lastU ? `${lastU}단원 세트 ${lastS} - ${parseInt(lastI)+1}번` : "기록 없음";
            document.getElementById('wrong-count').innerText = JSON.parse(localStorage.getItem('wrong_list') || "[]").length + "개";
        }

        function startSet(u, s, resumeIdx = 0) {
            setNum = s;
            curIdx = resumeIdx;
            isWrongMode = false;
            // 세트별 문제 분리 로직 (10개씩)
            const startIdx = (s - 1) * 10;
            currentSet = allQuestions.slice(startIdx, startIdx + 10);
            initQuiz();
        }

        function initQuiz() {
            document.getElementById('view-menu').classList.add('hidden');
            document.getElementById('view-quiz').classList.remove('hidden');
            loadQuestion();
        }

        function loadQuestion() {
            const data = isWrongMode ? JSON.parse(localStorage.getItem('wrong_list')) : currentSet;
            const q = data[curIdx];
            document.getElementById('display-title').innerText = isWrongMode ? "오답 복습" : `1단원 세트 ${setNum}`;
            document.getElementById('display-progress').innerText = `${curIdx+1}/${data.length}`;
            document.getElementById('q-text').innerText = q.q;
            document.getElementById('status-msg').innerText = '';
            document.getElementById('hint-box').classList.add('hidden');
            document.getElementById('row-next').classList.add('hidden');
            document.getElementById('row-check').classList.remove('hidden');

            if(!isWrongMode) {
                localStorage.setItem('last_unit', 1); localStorage.setItem('last_set', setNum); localStorage.setItem('last_idx', curIdx);
            }

            if(q.type === "S") {
                document.getElementById('area-subjective').classList.remove('hidden');
                document.getElementById('area-objective').classList.add('hidden');
                const input = document.getElementById('user-ans'); input.value = '';
                setTimeout(() => input.focus(), 100);
            } else {
                document.getElementById('area-subjective').classList.add('hidden');
                const objArea = document.getElementById('area-objective');
                objArea.classList.remove('hidden'); objArea.innerHTML = '';
                q.opts.forEach(opt => { objArea.innerHTML += `<button class="option-btn" onclick="checkObjective('${opt}')">${opt}</button>`; });
            }
        }

        document.addEventListener('keydown', (e) => {
            if (document.getElementById('view-quiz').classList.contains('hidden')) return;
            if (e.key === 'Enter') {
                const rowCheck = document.getElementById('row-check');
                if (!rowCheck.classList.contains('hidden')) checkAnswer();
                else nextQuestion();
            } else if (e.key === 'Control') { e.preventDefault(); toggleHint(); }
        });

        function checkAnswer() {
            const user = document.getElementById('user-ans').value.trim().toLowerCase().replace(/\s+/g, '');
            const data = isWrongMode ? JSON.parse(localStorage.getItem('wrong_list')) : currentSet;
            const q = data[curIdx];
            const isCorrect = q.a.some(ans => ans.toLowerCase().replace(/\s+/g, '') === user);
            showResult(isCorrect);
        }

        function checkObjective(val) {
            const q = currentSet[curIdx];
            showResult(q.a.includes(val));
        }

        function showResult(isCorrect) {
            const msg = document.getElementById('status-msg');
            const q = (isWrongMode ? JSON.parse(localStorage.getItem('wrong_list')) : currentSet)[curIdx];
            
            // 최초 응답만 기록 (이전 문제로 돌아와서 다시 풀어도 점수 반영 안됨)
            const scoreKey = `${setNum}_${curIdx}`;
            if(!isWrongMode && firstTryResults[scoreKey] === undefined) {
                firstTryResults[scoreKey] = isCorrect;
            }

            if(isCorrect) { msg.innerText = "✓ 확인됨"; msg.style.color = "#aaa"; }
            else { msg.innerText = `✕ 미일치 (정답: ${q.a[0]})`; msg.style.color = "#d9534f"; saveWrong(q); }
            document.getElementById('row-check').classList.add('hidden');
            document.getElementById('row-next').classList.remove('hidden');
        }

        function saveWrong(q) {
            let list = JSON.parse(localStorage.getItem('wrong_list') || "[]");
            if(!list.some(item => item.q === q.q)) { list.push(q); localStorage.setItem('wrong_list', JSON.stringify(list)); }
        }

        function nextQuestion() {
            const data = isWrongMode ? JSON.parse(localStorage.getItem('wrong_list')) : currentSet;
            if(curIdx < data.length - 1) { curIdx++; loadQuestion(); }
            else {
                if(!isWrongMode) {
                    const score = Math.round((Object.keys(firstTryResults).filter(k => k.startsWith(`${setNum}_`) && firstTryResults[k]).length / data.length) * 100);
                    localStorage.setItem(`score_1_${setNum}`, score);
                    alert(`세트 종료! 점수: ${score}점`);
                }
                goHome();
            }
        }

        function prevQuestion() {
            if(curIdx > 0) { curIdx--; loadQuestion(); }
            else { alert("첫 번째 문제입니다."); }
        }

        function resumeLast() {
            const u = localStorage.getItem('last_unit');
            const s = localStorage.getItem('last_set');
            const i = localStorage.getItem('last_idx');
            if(u && s) startSet(parseInt(u), parseInt(s), parseInt(i));
            else alert("기록이 없습니다.");
        }

        function startWrongAnswers() {
            const list = JSON.parse(localStorage.getItem('wrong_list') || "[]");
            if(list.length === 0) return alert("기록 없음");
            isWrongMode = true; curIdx = 0; initQuiz();
        }

        function toggleHint() {
            const data = (isWrongMode ? JSON.parse(localStorage.getItem('wrong_list')) : currentSet)[curIdx];
            const box = document.getElementById('hint-box');
            box.innerText = data.h; box.classList.toggle('hidden');
            if(data.type === "S") document.getElementById('user-ans').focus();
        }

        function goHome() { location.reload(); }
        renderMenu();
    </script>
</body>
</html>
